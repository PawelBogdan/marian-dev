import os
import platform
import shutil
import sys

from pathlib import Path
from setuptools import setup, find_namespace_packages, Distribution

"""
This script expects _pymarian.*.so to be present in $CMAKE_BINARY_DIR

NOTE: Most of (static) metadata is set in pyproject.toml.
#  This setup.py is for specifying dynamic aspect of build. All static metadata is in pyproject.toml
"""

DEF_CMAKE_BINARY_DIR = (Path(__file__).parent / '../../build').resolve()
CMAKE_BINARY_DIR = os.getenv("CMAKE_BINARY_DIR", DEF_CMAKE_BINARY_DIR)
print("\t>>>CMAKE_BINARY_DIR is ", CMAKE_BINARY_DIR)

if platform.system() == 'Windows':
    NATIVE_EXT_GLOB = '_pymarian.*.pyd'
elif platform.system() == 'Darwin':
    NATIVE_EXT_GLOB = '_pymarian.*.dylib'
else:
    NATIVE_EXT_GLOB = '_pymarian.*.so'


def get_version(cuda_version=None) -> str:
    vfile = Path(__file__).parent / '../../VERSION'
    if not vfile.exists() and "CMAKE_SOURCE_DIR" in os.environ:
        # some build tools may copy src/python into a temporary directory, which disconnects it from the source tree
        # using CMAKE_SOURCE_DIR to find the source tree
        vfile = Path(os.environ["CMAKE_SOURCE_DIR"]) / 'VERSION'
    try:
        assert vfile.exists(), f'Version file {vfile.resolve()} does not exist'
        version = vfile.read_text().strip().lstrip("v")  # gets rid of 'v' prefix in v1.17.5 etc.
    except:
        # FIXME: This is a hack. We need to read version from VERSION file
        version = '0.0.0'
        print(
            f'WARNING: Could not read version from {vfile.resolve()}. Setting version to {version}',
            file=sys.stderr,
        )
    version = version if not cuda_version else f"{version}+cu{cuda_version.replace('.', '')}"

    print("\t>>>Marian version is ", version)
    # we need to write version to _version.py file, so that it can be imported from python
    vfile_lines = [
        "# File generated by setuptools; it will be overwritten on every build",
        "# Hence, do not edit or track this file in version control",
        f"__version__ = '{version}'",
        "__cuda_version__ = %s" % ("None" if not cuda_version else f"'{cuda_version}'"),
    ]

    vfile_py = Path(__file__).parent / 'pymarian' / '_version.py'
    vfile_py.write_text("\n".join(vfile_lines))
    return version


def get_native_ext() -> Path:

    native_exts = list(Path(CMAKE_BINARY_DIR).glob(f'src/{NATIVE_EXT_GLOB}'))
    if not native_exts:
        raise Exception(
            f'No native extension found; Looked at {CMAKE_BINARY_DIR}/src/{NATIVE_EXT_GLOB}. \
            Please run cmake build first with -DPYMARIAN=ON or set CMAKE_BINARY_DIR to the build dir'
        )
    elif len(native_exts) >= 2:
        raise Exception(f'Only one native extension expected, but found: {native_exts}')

    native_ext = native_exts[0]
    # Pip does not allow inclusion of files from parent dir our outside of package context (for security reasons).
    # So, we copy the native extension to the package directory
    native_ext_local = Path(__file__).parent / native_ext.name
    print(f"\t>>>Found native extension at: {native_ext}")
    print(f"\t   >>>Making it available under scope at: {native_ext_local}")
    if native_ext_local.exists():
        native_ext_local.unlink()
    shutil.copy(native_ext, native_ext_local)
    return native_ext_local


version = get_version(os.getenv("CUDA_VERSION", default=""))
native_ext = get_native_ext()


# Thanks to https://stackoverflow.com/a/62668026/1506477
class BinaryDistribution(Distribution):
    """Distribution which always forces a binary package with platform name"""

    def has_ext_modules(foo):
        return True


setup(
    version=version,
    package_dir={"pymarian": "pymarian"},
    packages=find_namespace_packages(where=".", exclude=["tests", "binding"]),
    include_package_data=True,
    package_data={"": [str(native_ext)]},
    distclass=BinaryDistribution,
)
